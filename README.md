# Вычисляем и добавляем колонку "session_id" к датафрейму
Пример работы с pandas

![image](https://user-images.githubusercontent.com/40138357/199262774-42d5806c-b802-4a4e-8643-f572bbaa3b6d.png)

- Реализацию основного алгоритма можно найти в файле add_session_id/session_addder.py, методе SessionAdder.add_session_id()
- Дополнительные утилиты, например генератор датафреймов или декоратор обеспечивающий логирование находится в add_session_id/utils.py
- Так же реализовано логирование (через библиотеку loguru), написанны тесты (pytest), добавленны конфиги (dotenv)

Первый запуск:

Для работы скрипта требуется python версии 3.10 и библиотеки, перечисленные в файле add_session_id/requirements/requirements.txt

В корневой папке проекта требуется запустить файл install.sh

bash install.sh

В этом файле содержатся команды который можно выполнить по отдельности. Первая устанавливает код репозитория как зависимость для вашего интерпретатора. Вторая устанавливает все необходимые библиотеки

pip install -e .
pip install -r add_session_id/requirements/requirements.txt

Подготовив окружения мы можем запустить программу, для этого нам нужен файл add_session_id/main.py

python add_session_id/main.py


В корневой папке есть файл config.env. Через него можно осуществить настройку поведения программы

Поля:
LOGGING_LEVEL - уровень логов в std.err
LOGGING_DIR_LEVEL - Уровень логов в файл
LOG_DIR - Директория куда будут складываться логи. Если не задавать этот конфиг, то логи будут писаться только в std.err

DF_FROM_FILE - Прочитать df из файла csv или сгенерировать его
INPUT_FILE_PATH - Путь до файла с исходными данными. Применяется если DF_FROM_FILE=True

Если мы решим генерировать, а не читать датафрейм то нам доступны следующие параметры

N_CUSTOMERS - количестов различных покупателей в датасете
N_PRODUCTS - количестов различных продуктов
N_ROWS - количество строк в датасете (кол-во просмотров товаров)
START_TIME - минимально возможная временная метка в формате "YYYY-MM-dd HH:mm:ss"
END_TIME - максимально возможная временная метка в формате "YYYY-MM-dd HH:mm:ss"

SAVE_GEN_DF - Сохранить или нет в файл сгенерированный датасет
SAVE_GEN_FILE_PATH - Путь куда сохранится сгенерированный датасет. Применяется только если SAVE_GEN_DF=True

SAVE_RES_DF=False - Сохранить или нет в файл результирующий датасет (с колонкой session_id)
OUTPUT_FILE_PATH - Путь куда сохранится результирующий датасет. Применяется только если SAVE_GEN_DF=True


Тесты:

(тестовый стэнд: intel i5-11400H 2.7Gh, 16гб RAM, запуск из под WSL)
Запустить тесты можно из коневой папки командой:

pytest -v --capture=no  tests/test_session_adder.py

либо командой (содержит ту же команду):

bash test.sh

в файле tests/test_session_adder.py 3 теста:

1. Проверка работы генератора датафрейма
2. Проверка правильности работы алгоритма на данных небольшого размера. Просисходит сравнение результирующего датафрейма и заранее подготовленнного правильного решения
3. Тест изучающий временную сложность. Происходит генерация и обработка нескольких датасетов размером от 10 млн. до 100 млн. строк. Количестово покупателей в датасете   пропорционально количеству строк и всегда = n_row/ 100_000

Количство затраченных милисекунд отмечается на графике:


Алгоритм отрабатывает даже на больших значениях, исследуемый датасет может быть размером до 100 млн. строк. Как видно из графика алгоритм работает за ленейное время, пока не упирается в ограничения оперативной памяти. Это происходит примерно на 80-90 млн. записей.

Внимание!
Будьте осторожны при запуске программы с большии значениями N_ROWS или N_CUSTOMERS
